WEBVTT

0
00:00.780 --> 00:05.280
SQL Server-Clientcode; Herstellen einer Verbindung mit dem SQL-Server über Ihren eigenen Code.

1
00:07.780 --> 00:13.540
Verbinden von SQL Server mit Ihrem eigenen Code; Ihre Datenbank wird Sie sehr wahrscheinlich außerhalb des Codes verbinden

2
00:14.080 --> 00:17.470
entweder auf eine Website oder eine Anwendung.

3
00:17.650 --> 00:24.580
Hier werden wir uns ganz kurz ansehen, wie verschiedene Programmiersprachen speziell eine Verbindung zu SQL Server herstellen können;

4
00:25.240 --> 00:27.390
, Knoten, Python und Java.

5
00:29.670 --> 00:36.450
Einige Vorbehalte; wir werden nicht in serames Detail auf einer der Client-Sprachen gerade genug zu zeigen

6
00:36.450 --> 00:38.580
wie Sie eine Verbindung mit Ihrer Datenbank herstellen und aus ihr lesen.

7
00:39.840 --> 00:43.400
Es gibt viele verschiedene Bibliotheken und Möglichkeiten, diesen Typ von Clientcode zu schreiben.

8
00:43.410 --> 00:49.700
Dies ist nur eine Möglichkeit, es zu tun und ich versuchte, es einfach zu halten 

9
00:49.710 --> 00:55.320
Verbindungszeichenfolgen; Ein gemeinsames Merkmal der meisten Clientsprachen ist, dass sie eine Verbindungszeichenfolge verwenden, um die

10
00:55.320 --> 00:58.050
Verbindung zwischen dem Code und der Datenbank.

11
00:58.050 --> 01:04.500
Diese Zeichenfolge definiert; Der Speicherort der Datenbank, d. h. localhost oder Remote IP.

12
01:04.850 --> 01:12.210
Die zu verwendende Standarddatenbank (d. h. Bibliothek); Die Zugriffsanmeldeinformationen, d. h. SQL Server-Authentifizierungsbenutzername

13
01:12.210 --> 01:18.080
und Passwort oder Windows-Authentifizierung; und die Datenbanktreibersoftware, d. h. SQL Server.

14
01:18.150 --> 01:26.500
Fortsetzung; Hier in diesem Beispiel einer Verbindungszeichenfolge, die von Python verwendet wird.

15
01:26.640 --> 01:35.600
Die pyODBC-Bibliothek; 

16
01:36.090 --> 01:43.680
Server=localhost; Database=Bibliothek; Trusted_Connection=Ja; Treiber = SQL-Server

17
01:45.120 --> 01:48.870
bedeutet, dass die Datenbank jemals gefunden und localhost; die gleiche Maschine.

18
01:48.870 --> 01:51.950
Die ursprüngliche Datenbank, die verwendet werden soll, ist "Bibliothek".

19
01:51.950 --> 01:57.690
Wir verwenden die Windows-Authentifizierung, und die zu verwendende Treibersoftware ist SQL Server.

20
01:57.960 --> 02:03.090
Andere Eigenschaften können in der Verbindungszeichenfolge definiert werden, z. B. Verschlüsselung, Verbindungs-Timeouts und

21
02:03.090 --> 02:04.550
Wenn Ihre Datenbank einen anderen Port als 1433 verwendet

22
02:04.560 --> 02:14.550
Datenbanktreiber; Eine Datenbankbibliothek kann für eine Datenbank spezifisch sein, d. h. SQL Server

23
02:15.060 --> 02:22.050
oder eine andere Art von Datenbank wie mySQL; in Fällen, in denen ein bestimmter Datenbanktreiber verfügbar ist und

24
02:22.050 --> 02:26.940
Sie haben nicht die Absicht, den Typ der Datenbank zu ändern, die Sie verwenden, dann bietet ein bestimmter Treiber bessere

25
02:26.940 --> 02:34.330
Leistung und Funktionen. Wenn Sie eine Datenbankbibliothek verwenden, die nicht für SQL Server spezifisch ist,

26
02:34.340 --> 02:40.830
als eine basierte odBC (offene Datenbankkonnektivität) oder OLEDB (Objektverknüpfung und Einbettungsdatenbank)

27
02:41.910 --> 02:48.820
Dann müssen Sie angeben, dass der Treiber SQL Server verwenden soll

28
02:48.830 --> 02:54.270
C-Code (.NET);  wenn Sie eine Website auf ASP.NET hosten oder ausführen 

29
02:54.370 --> 02:55.570
Eine Windows-Desktop-App

30
02:55.920 --> 02:58.290
Dann ist c- eine gute Wahl.

31
02:58.290 --> 03:02.810
Sie können den Code von GitHub herunterladen oder der Videodemo folgen.

32
03:03.060 --> 03:09.830
https://github.com/infiniteloopltd/SQLDotNetCore

33
03:12.420 --> 03:19.130
Videodemonstration; Hier erfahren Sie, wie Sie eine Verbindung mit unserer Datenbank über c. (.NET Core) herstellen.

34
03:19.560 --> 03:27.820
Ich werde nun zeigen, wie eine Verbindung mit dem SQL-Server mithilfe von C- hergestellt wird. zuerst eröffnen visuelles Studio.

35
03:27.860 --> 03:30.330
In diesem Fall habe ich Visual Studio 2019.

36
03:30.560 --> 03:35.420
Aber jede andere Version von Visual Studio 

37
03:35.420 --> 03:42.850
Drücken Sie die Eingabe eines neuen Projekts. Ich werde eine neue Konsolen-App mit dem .NET-Kernframework erstellen.

38
03:44.090 --> 03:44.780
Drücken Sie als nächstes.

39
03:46.790 --> 03:57.690
Es gibt dem Projekt einen Namen; die ich SQLDotNetCore nennen werde; Drücken Sie create;

40
04:06.070 --> 04:08.850
Warten Sie, bis das Projekt erstellt wurde. und die Benutzeroberfläche zum Laden

41
04:49.600 --> 04:57.110
OK, es ist jetzt geladen; und wir haben ein Hello World Programm auf dem Bildschirm; Sie können bemerken, dass ich einen Paketmanager habe

42
04:57.130 --> 04:58.230
Konsolenfenster.

43
04:58.330 --> 05:08.980
Und wenn Sie diese nicht haben, dann drücken Sie Werkzeuge; NuGet-Paket-Manager und Paket-Manager-Konsole; Weil

44
05:08.980 --> 05:15.190
Das erste, was wir tun müssen, ist tatsächlich ein NuGet-Paket für SQL Server zu installieren, das wir eingeben

45
05:15.190 --> 05:18.670
Install-Package System.Data.SqlClient

46
05:21.340 --> 05:22.940
Install-Package System.Data.SqlClient

47
05:22.940 --> 05:27.930
Install-Package System.Data.SqlClient

48
05:31.110 --> 05:38.980
Dies wird unsere SQL-Client-Bibliothek herunterladen, auf die wir hier verweisen können.

49
05:39.230 --> 05:46.640
Verwendung von System.Data.SqlClient;

50
05:46.640 --> 05:48.420
Es sollte im Intelisense angezeigt werden, wenn es richtig installiert ist.

51
05:48.640 --> 05:55.820
Jetzt brauchen Sie die Hello-Welt nicht mehr; aber was wir brauchen, ist eine Verbindungszeichenfolge.

52
05:55.850 --> 06:01.670
Jetzt werde ich dies als const definieren, weil es sich nicht ändern wird.

53
06:02.090 --> 06:04.590
const string connectionString =
"Datenquelle=localhost; Initial Catalog=Library; Integrierte Sicherheit=True;";

54
06:07.170 --> 06:10.770
const string connectionString =
"Datenquelle=localhost; Initial Catalog=Library; Integrierte Sicherheit=True;";

55
06:10.800 --> 06:20.130
const string connectionString =
"Datenquelle=localhost; Initial Catalog=Library; Integrierte Sicherheit=True;";

56
06:20.130 --> 06:23.550
const string connectionString =
"Datenquelle=localhost; Initial Catalog=Library; Integrierte Sicherheit=True;";

57
06:24.190 --> 06:26.900
const string connectionString =
"Datenquelle=localhost; Initial Catalog=Library; Integrierte Sicherheit=True;";

58
06:28.700 --> 06:35.850
Wir verwenden die Windows-Authentifizierung, die Sie effektiv mit demselben Benutzer verwenden, den ich bin

59
06:35.850 --> 06:36.420
angemeldet wie jetzt

60
06:36.450 --> 06:48.390
sollten wir integrierte Sicherheit verwenden= true, was bedeutet, dass der Benutzer

61
06:48.390 --> 06:52.820
das Programm ausführt, ist dasselbe, das sich in der Datenbank anmeldet.

62
06:52.980 --> 06:55.680
Also haben wir jetzt unsere Verbindungsschnur.

63
06:55.920 --> 07:00.770
Wir müssen ein SQL-Verbindungsobjekt erstellen, so dass:

64
07:01.090 --> 07:08.050
var-Verbindung = neue SqlConnection(connectionString);

65
07:11.310 --> 07:15.540
wir müssen die Verbindung öffnen.

66
07:15.990 --> 07:18.740
Dies funktioniert effektiv in der Datenbank.

67
07:18.730 --> 07:24.210
Nun definieren wir unsere SQL-Anweisung; so einfach.

68
07:24.210 --> 07:34.580
const string sql = "select * from students";

69
07:34.890 --> 07:41.600
Jetzt definieren wir einen DataAdapter, ein Dataset.

70
07:41.800 --> 07:56.020
Wir werden den Datensatz über den dataAdapter so füllen;

71
07:56.010 --> 07:58.740
var adapter = neuer SqlDataAdapter(sql, Verbindung);

72
07:58.810 --> 08:05.950
Nicht die Verbindungszeichenfolge, die tatsächliche Verbindung; wir definieren Studenten

73
08:09.730 --> 08:12.160
als leeres Dataset

74
08:17.020 --> 08:22.330
Dies hat automatisch mit der system.data-Anweisung importiert.

75
08:26.110 --> 08:30.240
und wir verwenden den Datenadapter, um dieses Dataset zu füllen.

76
08:31.310 --> 08:40.050
Adapter. Fill (Studenten, "Studenten");

77
08:40.080 --> 08:42.290
Und wir geben der Datentabelle einen Namen, das könnte alles sein, aber ich werde es Studenten nennen

78
08:45.250 --> 08:46.350
Und dann..

79
08:49.030 --> 08:58.150
für jeden (DataRow-Schüler in Studenten. Tabellen["Studenten"]. Zeilen)

80
08:58.410 --> 09:00.550
für jeden (DataRow-Schüler in Studenten. Tabellen["Studenten"]. Zeilen)

81
09:00.570 --> 09:02.220
Das ist derselbe Text wie hier oben.

82
09:02.370 --> 09:06.080
Also

83
09:08.760 --> 09:14.940
Also, was wir sagen, es ist, dass, sobald wir das Ergebnis aus diesem durch jede Reihe in der resultierenden gehen

84
09:15.080 --> 09:19.090
Datentabelle; wir werden das auf den Bildschirm schreiben.

85
09:19.140 --> 09:21.400
Console.WriteLine(student["FirstName"] + " + student["Nachname"]);

86
09:27.750 --> 09:37.740
Student, was unsere Datenzeile ist; Vorname, der die Spalte ist; legen Sie einen Raum dort; und der Student

87
09:40.250 --> 09:42.590
Nachname.

88
09:43.630 --> 09:48.510
Halten Sie es ordentlich; und was wir tun werden, um aufzuräumen.

89
09:48.600 --> 09:50.200
Wir werden die Verbindung schließen.

90
09:50.250 --> 09:51.420
Wenn wir fertig sind.

91
09:51.480 --> 09:52.830
Dies ist optional.

92
09:52.840 --> 09:55.060
Aber gute Praxis.

93
09:55.060 --> 09:59.310
Und dann machen wir Console.ReadLine();

94
09:59.310 --> 10:08.020
Dies ist nur so, dass wir in der Lage sein werden, die Ausgabe davon zu sehen, wie es läuft.

95
10:08.350 --> 10:08.830
Okay.

96
10:08.880 --> 10:13.470
Jetzt haben wir unser Programm geschrieben alle oder ist links zu tun, wir führen diese

97
10:19.810 --> 10:20.500
Na bitte.

98
10:20.500 --> 10:30.610
Wir haben eine Liste unserer drei Studenten aus unserer Datenbank zurück; das ist also ein sehr kurzer Überblick darüber, wie

99
10:30.610 --> 10:38.490
, um eine Verbindung mit der Datenbank herzustellen und die Daten in C.NET Core zurückzulesen, 

100
10:38.680 --> 10:45.220
Wenn Sie eine Website entwickeln und bereits mit der Programmierung in JavaScript vertraut sind, dann ist NodeJS sowohl modern als auch bietet

101
10:45.340 --> 10:46.610
Lernkurve.

102
10:46.810 --> 10:51.620
Sie können den Code von github herunterladen oder dem Video folgen.

103
10:52.030 --> 10:56.410
https://github.com/infiniteloopltd/SQLNodeJS

104
10:56.430 --> 11:00.600
Video-Demonstration.

105
11:00.900 --> 11:08.460
Hier zeigen wir Ihnen, wie Sie eine Verbindung mit unserer Datenbank über nodeJS herstellen

106
11:08.590 --> 11:15.990
Okay; Daher werde ich jetzt zeigen, wie Sie mithilfe der Windows-Authentifizierung eine Verbindung mit der SQL Server-Datenbank herstellen

107
11:16.200 --> 11:20.860
und Knoten; also erneue ich die Eingabeaufforderung.

108
11:21.720 --> 11:24.140
Meine Knotenentwicklungsumgebung ist bereits installiert.

109
11:25.260 --> 11:35.970
Also möchte ich zuerst einen Ordner für das Knotenprojekt erstellen, damit ich es SQLNode nenne; 

110
11:35.970 --> 11:36.400
und navigieren Sie hinein.

111
11:40.120 --> 11:45.070
Dieses Verzeichnis ist leer. und ich möchte nun ein neues NPM-Paket erstellen.

112
11:45.100 --> 11:46.680
Also tippe ich NPM init ein

113
11:50.170 --> 11:57.130
Akzeptieren Sie alle Standardeinstellungen und wenn ich dies auslaufe, werden wir sehen, dass wir ein paket.json haben.

114
11:57.130 --> 12:05.860
Für uns generierte Datei; Jetzt muss ich als Erstes eine Bibliothek installieren, die

115
12:05.920 --> 12:10.500
Knoten zum Herstellen einer Verbindung mit SQL Server; jetzt, da ich die Windows-Authentifizierung verwende.

116
12:10.510 --> 12:15.300
Ich verwende eine Bibliothek, die mit der Windows-Authentifizierung funktioniert.

117
12:15.310 --> 12:17.230
Aber dies ist eigentlich nur Windows.

118
12:17.350 --> 12:21.250
Aber so ist das Paket, das ich im Begriff bin zu installieren.

119
12:21.250 --> 12:24.280
Es heißt msnodesqlv8

120
12:24.550 --> 12:37.060
Wenn ich also npm eintippe, füge msnodesqlv8 hinzu und dies wird dieses Paket herunterladen und es zu

121
12:38.180 --> 12:38.790
unser Projekt

122
12:41.040 --> 12:42.450
Die Ausführung dies jetzt.

123
12:42.450 --> 12:48.810
Wir können sehen, dass wir jetzt einen node_modules Ordner generiert haben.

124
12:48.930 --> 12:56.640
Das nächste, was ich tun würde, ist eine index.js-Datei zu erstellen und Code zu schreiben, um tatsächlich auf

125
12:56.640 --> 12:58.090
die Datenbank.

126
12:58.200 --> 13:05.830
Also werde ich eine ziemlich leere Datei namens index.js aus der Befehlszeile wie diese erstellen.

127
13:06.450 --> 13:14.640
Jetzt verwende ich editplus; Sie können jeden Texteditor verwenden, um dies wie Notepad, Atom, 

128
13:14.640 --> 13:16.110
visual Studio-Code.

129
13:17.930 --> 13:27.750
Edit Plus ist es nur eine persönliche Vorliebe; Wenn ich also jetzt meine Datei index.js öffne, habe ich eine hübsche

130
13:27.750 --> 13:31.770
viel leere Datei, in die ich jetzt Code schreiben werde.

131
13:32.460 --> 13:37.570
Das erste, was ich tun möchte, ist tatsächlich die Bibliothek zu importieren, die wir gerade heruntergeladen haben.

132
13:37.710 --> 13:47.380
const sql = require("msnodesqlv8"); 

133
13:47.450 --> 13:50.700
const sql = require("msnodesqlv8"); 

134
13:51.590 --> 14:02.910
Wie zuvor werden wir eine Verbindungszeichenfolge definieren;

135
14:03.410 --> 14:11.290
Es ist ein etwas anderes Format, weil dies ODBC ist, aber es definiert ziemlich die gleichen Eigenschaften

136
14:11.860 --> 14:21.700
so definieren wir, wo der Datenbankserver ist, der localhost ist; die gleiche Maschine; die ursprüngliche Datenbank.

137
14:21.710 --> 14:24.050
Also werden wir eine Verbindung herstellen ist "Bibliothek"

138
14:27.410 --> 14:33.350
und wir definieren eine vertrauenswürdige Verbindung, was bedeutet, dass das Windows-Konto, das zum Ausführen verwendet wird,

139
14:33.350 --> 14:41.290
Die Software ist dieselbe, die verwendet wird, um sich bei SQL Server anzumelden, d. h. mit der Windows-Authentifizierung

140
14:41.330 --> 14:47.470
Trusted_Connection=Ja

141
14:47.630 --> 14:54.560
Da es sich um einen ODBC handelt, müssen wir auch angeben, dass dies SQL Server ist, das wir verbinden.

142
14:54.560 --> 14:57.410
und es ist nicht in mySQL oder einer anderen Datenbank.

143
14:57.570 --> 15:07.580
Jetzt gibt es eine Reihe von Treibersoftwarepaketen wie SQL Server, SQL Server Native Client usw.

144
15:07.910 --> 15:10.300
Wir verwenden nur SQL Server.

145
15:10.310 --> 15:18.010
Wir werden hier keine erweiterten Funktionen verwenden, also sollte SQL Server uns tun, 

146
15:18.010 --> 15:18.700
jetzt ist das unsere Verbindungszeichenfolge definiert

147
15:18.710 --> 15:31.170
Wir verwenden jetzt sql.query und übergeben die Verbindungszeichenfolge und übergeben eine SQL-Anweisung, die 

148
15:31.170 --> 15:34.620
Wählen * von Studenten

149
15:36.300 --> 15:45.110
Der dritte Parameter ist eine Rückruffunktion, die zwei Parameter übergeben wird; ein Fehler und ein Datensatzsatz

150
15:47.410 --> 15:52.680
wir definieren dies also als Pfeilfunktion.

151
15:53.140 --> 15:54.410
Wir werden dies abschotten.

152
15:56.590 --> 16:04.990
Nun gibt diese Pfeilfunktion entweder Fehler oder einen Datensatz zurück; gut, es wird beides zurückgeben; aber einer der

153
16:04.990 --> 16:07.120
zwei werden relevante Informationen enthalten.

154
16:07.840 --> 16:14.550
Also, wenn wir sagen; wenn der Fehler mit etwas aufgefüllt wird; dann ist etwas Schlimmes passiert.

155
16:14.710 --> 16:23.140
Wir möchten das auf den Bildschirm schreiben; so console.log(err); und kehren Sie zurück, weil der Datensatz

156
16:23.140 --> 16:25.400
nutzlos sein.

157
16:25.600 --> 16:27.690
Wenn der Fehler jedoch null ist

158
16:27.700 --> 16:33.460
Das hat also funktioniert; wir durch den Datensatz satzdurchziehen und die Ergebnisse auf die

159
16:33.460 --> 16:33.820
Bildschirm.

160
16:34.030 --> 16:37.500
für(var i in recordset)

161
16:42.160 --> 16:44.080
"i" wird ein Indexer sein.

162
16:44.290 --> 16:50.670
var row = recordset[i];

163
16:54.030 --> 17:01.320
, um dies auf den Bildschirm zu schreiben: console.log(row. Vorname + ' ' + Zeile. Nachname);

164
17:01.490 --> 17:06.200
Beachten Sie, dass dies groß ist, also stellen Sie sicher, dass Ihre

165
17:09.350 --> 17:14.490
Variablen stimmen hier genau mit den Spaltennamen überein.

166
17:15.170 --> 17:17.770
Wir werden von dieser Funktion zurückkehren.

167
17:19.860 --> 17:27.900
Um dies zu speichern, gehen Sie zurück in unser Eingabeaufforderungsfenster.

168
17:28.200 --> 17:30.570
Mal sehen, ob das funktioniert.

169
17:31.050 --> 17:32.730
Knoten Index.js.

170
17:32.760 --> 17:33.310
Na bitte.

171
17:33.320 --> 17:38.420
Die anderen drei Studenten aus unserem Studententisch.

172
17:38.500 --> 17:42.040
Das war also eine sehr schnelle Einführung in SQL Server und Node

173
17:42.080 --> 17:50.940
Python; Wenn Sie eine Anwendung schreiben, die machine Learning oder statistische Funktionen verwenden kann, dann

174
17:50.940 --> 17:55.750
Python ist eine gute Wette; Sie können den Code von github herunterladen oder der Videodemo folgen.

175
17:55.930 --> 18:01.010
https://github.com/infiniteloopltd/SQLPython

176
18:01.050 --> 18:05.430
Video-Demonstration.

177
18:05.580 --> 18:10.500
Hier zeigen wir, wie Sie mit Python eine Verbindung zu unserer Datenbank herstellen.

178
18:10.500 --> 18:15.830
Wir werden nun zeigen, wie Sie über Python eine Verbindung mit dem SQL-Server herstellen.

179
18:15.960 --> 18:21.780
Also wieder einmal erweitere ich meine Eingabeaufforderung und ich werde einen neuen Ordner für mein Python-Projekt erstellen

180
18:21.780 --> 18:26.130
Ich werde es SQLPython nennen

181
18:26.440 --> 18:31.110
Erstellen Sie einen neuen Ordner, und wechseln Sie ihn. 

182
18:36.220 --> 18:38.670
Das Verzeichnis ist leer.

183
18:38.740 --> 18:48.780
Das erste, was ich tun möchte, ist das Python-Paket zu installieren, das für den Zugriff auf SQL Server erforderlich ist.

184
18:49.250 --> 19:01.340
Und ich werde zu pyodbc, So ich typ pip install pyodbc

185
19:01.470 --> 19:05.740
Dieses Paket wurde bereits auf meinem lokalen Computer installiert.

186
19:05.790 --> 19:13.820
Wir erstellen jetzt eine Skriptdatei, damit script.py erstellt werden.

187
19:13.940 --> 19:21.030
Wir werden editplus oder einen beliebigen Texteditor öffnen, wir werden die script.py

188
19:21.030 --> 19:21.390
Also...

189
19:22.680 --> 19:30.450
Das erste, was wir tun wollen, ist die pyodbc Bibliothek importieren

190
19:34.440 --> 19:44.960
wir definieren eine Verbindung; so conn = pyodbc.connect

191
19:45.330 --> 19:51.840
Wir werden die Verbindungszeichenfolge wie bisher übergeben; Diese Verbindungszeichenfolge ist ziemlich identisch

192
19:51.840 --> 20:03.210
zu dem, der im Knoten verwendet wird; So definieren wir den Server=Localhost wie in diesem Computer

193
20:03.960 --> 20:11.400
Die Datenbank ist "Bibliothek", was unsere erste Datenbank ist, also werden wir verwenden; und wir werden die Windows-Authentifizierung verwenden.

194
20:11.520 --> 20:15.970
Daher möchten wir vertrauenswürdige Trusted_Connection= Ja definieren

195
20:16.020 --> 20:22.530
Das bedeutet, dass der Benutzer, der zum Ausführen dieser Anwendung verwendet wird, auch derjenige ist, der sich bei SQL anmeldet.

196
20:22.530 --> 20:22.950
Server.

197
20:23.760 --> 20:30.490
So ist es Trusted_Connection=Ja

198
20:30.750 --> 20:37.740
Erneut definieren wir den Treiber, der angibt, dass wir eine Verbindung mit SQL Server und nicht mit mySQL herstellen.

199
20:37.770 --> 20:47.910
oder Oracle oder so etwas;  Treiber = SQL-Server

200
20:47.910 --> 21:04.560
Das ist der ODBC-Treiber, der verwendet wird;  wir definieren den Cursor; cursor = conn.cursor()

201
21:08.370 --> 21:13.420
Das kommt von unserem Verbindungsobjekt.

202
21:13.620 --> 21:16.870
Wir werden einige SQL auf unserem Cursor ausführen.

203
21:18.010 --> 21:20.260
cursor.execute('

204
21:23.400 --> 21:24.890
Wir schreiben eine SQL-Anweisung

205
21:24.930 --> 21:27.120
Wählen * von Studenten

206
21:34.000 --> 21:40.810
für jede Zeile im zurückgegebenen Cursor.

207
21:40.920 --> 21:44.430
für Zeile im Cursor:

208
21:47.490 --> 21:54.200
wir drucken; Der Cursor hat keine benannten Spalten.

209
21:54.810 --> 22:04.670
Also verwenden wir Indizes so 0 und 1, um zufällig der Vor- und Nachname des Studenten zu sein.

210
22:04.740 --> 22:07.080
Das ist also wirklich alles, was es dazu gibt.

211
22:07.080 --> 22:19.740
Wir speichern, dass wir in unsere Eingabeaufforderung zurückkehren und Python script.py ausführen.  und da haben wir es

212
22:19.740 --> 22:19.830
..

213
22:19.860 --> 22:27.210
Wir haben die drei Studenten aus unserem Studententisch, so dass eine sehr schnelle Einführung in den Zugriff auf

214
22:27.270 --> 22:28.180
SQL Server.

215
22:28.200 --> 22:33.590
Windows-Authentifizierung in Python.

216
22:33.970 --> 22:40.240
Java; Wenn Sie Java an der Universität gelernt haben oder Sie Haben Erfahrung beim Programmieren mit Android, dann würden Sie sicherlich

217
22:40.240 --> 22:41.920
mit Java gehen.

218
22:42.010 --> 22:47.530
Sie können den Code von github herunterladen, folgen Sie der Video-Demo.

219
22:47.530 --> 22:55.900
https://github.com/infiniteloopltd/SQLJava

220
22:55.900 --> 22:58.240
Video-Demonstration: Hier zeigen wir, wie Sie sich mit Java mit unserer Datenbank verbinden.

221
22:58.900 --> 23:05.610
Hier werde ich zeigen, wie Sie eine Verbindung mit SQL Server über Windows-Integration und Java als Client herstellen.

222
23:05.620 --> 23:06.330
Sprache.

223
23:06.850 --> 23:15.790
Also zuerst werde ich Ihren Projektordner erstellen; md SQLJava

224
23:15.820 --> 23:23.950
Dieser Ordner ist leer; Jetzt wie bisher benötige ich eine Client-Software, um eine Verbindung herzustellen

225
23:23.980 --> 23:25.530
SQL Server.

226
23:25.780 --> 23:29.710
Sie können dies aus dem GitHub-Repository für dieses Projekt herunterladen.

227
23:29.990 --> 23:37.220
Also werden wir zum Github-Ordner navigieren; https://github.com/infiniteloopltd/SQLJava

228
23:37.570 --> 23:39.930
Was Sie brauchen, sind diese beiden Dateien hier.

229
23:41.190 --> 23:42.660
Also die Jar-Datei; Herunterladen;

230
23:47.240 --> 23:55.580
und wir brauchen auch sqljdbc_auth.dll

231
23:55.850 --> 23:57.200
Dies ist für die Windows-Authentifizierung erforderlich.

232
23:57.230 --> 24:01.010
wir werden beides herunterladen.

233
24:01.080 --> 24:06.440
Es gibt eine Warnung in Chrome, da dies möglicherweise ausführbare Dateien sein kann; Aber ich werde druckn.

234
24:06.440 --> 24:08.770
Halten; und vertrauen Sie diesen beiden Dateien.

235
24:09.200 --> 24:13.510
Ich werde dies nicht aus meinem Downloadordner kopieren.

236
24:17.900 --> 24:21.970
Fügen Sie es in diesen Ordner ein.

237
24:32.300 --> 24:35.320
wir sollten sehen, dass diese Dateien vorhanden sind.

238
24:35.320 --> 24:43.840
Also das nächste, was wir tun müssen, ist eine Java-Datei zu erstellen, so dass ich werde unsere ziemlich leere Java erstellen

239
24:43.840 --> 24:45.100
Datei, die wir SQLJava.java nennen

240
24:50.180 --> 24:55.280
und wieder einmal werden wir dies in unserem treuen editplus

241
24:58.300 --> 25:04.550
navigieren Sie zum Ordner;  öffnen sqljava.java

242
25:05.880 --> 25:07.230
Wir brauchen also

243
25:10.170 --> 25:11.720
Öffentliche Klasse SQLJava

244
25:11.730 --> 25:12.170
Öffentliche Klasse SQLJava

245
25:16.900 --> 25:21.370
Wir werden hier unsere Hauptmethode erstellen, die statisch ist

246
25:30.470 --> 25:35.650
möglicherweise könnten wir Befehlszeilenargumente übergeben, aber diese werden nicht verwendet.

247
25:38.940 --> 25:46.410
Jetzt wie bisher werden wir unsere DSN definieren; oder Verbindungszeichenfolge;

248
25:46.470 --> 25:55.740
in Java gibt es ein wenig anders, aber es enthält die gleichen Informationen; so werden wir;

249
25:56.350 --> 26:02.510
String dsn = "jdbc:sqlserver://localhost;databaseName=Library;integratedsecurity=true";

250
26:02.620 --> 26:14.020
String dsn = "jdbc:sqlserver://localhost;databaseName=Library;integratedsecurity=true";

251
26:14.060 --> 26:21.300
die localhost (die gleiche Maschine) ist; Wir definieren den Datenbanknamen als "Bibliothek"

252
26:24.480 --> 26:34.110
und wir erklären die integrierte Sicherheit für wahr

253
26:34.820 --> 26:44.820
integratedsecurity=true

254
26:44.890 --> 26:53.970
Jetzt werden wir dies in einem Try Catch umschließen, da Java Methoden erfordert, die eine Ausnahme auslösen können

255
26:54.030 --> 26:56.490
so in Versuchsfang eingewickelt werden.

256
26:56.490 --> 27:02.340
Also versuchen wir / fangen (Ausnahme e)

257
27:06.870 --> 27:10.180
und wir drucken einfach die Stapelablaufverfolgung.

258
27:10.200 --> 27:15.880
Wenn eine Ausnahme auftreten sollte; e.printStackTrace();

259
27:19.880 --> 27:29.870
in unseren Versuchsblock; wir werden ein Verbindungsobjekt erstellen;  

260
27:31.270 --> 27:34.970
Verbindung conn = DriverManager.getConnection(dsn);

261
27:35.930 --> 27:38.420
Jetzt deklarieren wir hier zwei neue Objekte.

262
27:38.450 --> 27:39.980
Und deshalb müssen wir diese importieren.

263
27:39.980 --> 27:43.810
java.sql.Connection importieren;

264
27:46.630 --> 27:49.790
java.sql.DriverManager importieren;

265
27:57.070 --> 27:59.250
wir werden keine Anweisung erstellen.

266
27:59.570 --> 28:09.280
Anweisung stmt = conn.createStatement();      

267
28:11.900 --> 28:17.870
wieder einmal verwenden wir ein neues Objekt; Also müssen wir das importieren - java.sql.Statement importieren;

268
28:21.850 --> 28:24.730
Jetzt verwenden wir ein Resultset-Objekt

269
28:28.510 --> 28:32.060
ResultSet result = stmt.executeQuery("..

270
28:32.550 --> 28:34.210
ResultSet result = stmt.executeQuery("..

271
28:37.930 --> 28:43.060
und hier schreiben wir die SQL-Anweisung "Select * from students"

272
28:46.600 --> 28:50.610
Also alles gut läuft wir sollten ein Ergebnisset haben

273
28:50.650 --> 28:57.610
Wir werden also durch das folgende Ergebnis iterieren; während (result.next())

274
29:05.310 --> 29:11.130
String-Vorname = result.getString("Vorname");

275
29:22.020 --> 29:23.740
Zeichenfolgenname = result.getString("Nachname"); 

276
29:26.320 --> 29:29.780
Zeichenfolgenname = result.getString("Nachname"); 

277
29:35.920 --> 29:38.510
und dann werden wir das auf den Bildschirm schreiben;

278
29:49.630 --> 29:57.670
Also alles gut, die auf dem Bildschirm ausdrucken sollte.

279
29:57.700 --> 30:05.440
Ich habe bereits das Anweisungsobjekt.

280
30:09.530 --> 30:16.880
speichern Sie dies; wir werden hoffentlich diese Zusammenstellung sehen; also geben wir javac sqljava.java ein

281
30:26.960 --> 30:29.300
Jetzt haben wir also eine Klassendatei

282
30:29.390 --> 30:33.630
SQLJava.class; jetzt, wenn Sie dies ausführen.

283
30:33.650 --> 30:44.690
Wir müssen die JAR-Datei in den Klassenpfad aufnehmen, damit wir Folgendes eingeben:

284
30:44.690 --> 30:49.250
java -cp ".; sqljdbc42.jar" SQLJava

285
30:52.970 --> 30:53.910
java -cp ".; sqljdbc42.jar" SQLJava

286
30:53.970 --> 30:56.640
java -cp ".; sqljdbc42.jar" SQLJava

287
30:56.740 --> 31:06.770
Nun sollte ich sagen, dass diese JAR-Datei und DLL für JRE 18 und eine 64-Bit-Maschine entwickelt wurden.

288
31:06.870 --> 31:15.330
Wenn Sie Java Version 1.18 (JRE 18) nicht oder nicht auf 64 Bit ausführen

289
31:15.330 --> 31:19.560
Maschine und Sie benötigen möglicherweise eine andere JAR- und DLL-Datei hier

290
31:23.350 --> 31:29.210
und wir geben den Namen der Klasse SQLJava ein und führen diese aus.

291
31:32.910 --> 31:39.960
und da gehen wir hin; unsere drei Studenten; das war also eine sehr schnelle Einführung in Java.

292
31:40.290 --> 31:48.770
Und eine Verbindung mit SQL Server herstellen, aber hoffentlich hat es Sinn gemacht. ... Und es liegt an Ihnen - mit jeder Sprache Ihrer Wahl

293
31:49.120 --> 31:55.790
C-, Knoten-, Python- oder Java-Code - Schreiben Sie eine Konsolenanwendung, die den Benutzer zur Eingabe eines Vornamens und

294
31:55.790 --> 32:02.750
Nachname eines neuen Studenten fügt einen neuen Studenten in die Datenbank ein; die Anwendung darf nicht anfällig für

295
32:02.780 --> 32:05.450
SQL-Injektionsangriffe.

296
32:05.900 --> 32:13.660
Also geben Sie dies ein Go und schauen Sie sich das Video für die Lösung.

297
32:13.650 --> 32:15.660
Ich hoffe, Sie haben diese Übung in sende Zeit in s. M. umgesieb.

298
32:15.680 --> 32:22.640
Wenn Sie dieses Video nicht angehalten haben, dann halten Sie dieses Video jetzt an; und geben Sie diese Übung zu gehen; Sie können eine beliebige Programmiersprache wählen

299
32:22.640 --> 32:30.560
Sie möchten aus der Wahl von C-, Python-, Node- oder Java-Option und dies zeigt Ihnen die Lösung in jedem

300
32:30.560 --> 32:32.050
dieser Sprachen.

301
32:32.150 --> 32:39.230
Die erste Lösung, die wir zeigen werden, ist also C.

302
32:39.350 --> 32:47.660
öffnen Sie unseren .Net-Core-Beispielcode, also warten wir nur darauf, dass das geladen wird, sollten einen Moment dauern.

303
33:07.960 --> 33:14.960
OK, jetzt haben wir wieder unseren Beispielcode, wir sollten einfach den Code herausnehmen, den wir nicht brauchen.

304
33:15.140 --> 33:20.220
Daher benötigen wir den Code nicht, um aus der Datenbank zu lesen.

305
33:20.480 --> 33:23.740
Im Moment brauchen wir unsere Verbindung.

306
33:23.990 --> 33:30.920
Was wir also tun wollen, ist, den Benutzer nach dem Vor- und Nachnamen des Studenten zu fragen.

307
33:31.160 --> 33:44.340
Also geben wir Console.WriteLine ein

308
33:50.650 --> 33:55.550
"Bitte geben Sie den Vornamen des Schülers ein"

309
34:06.000 --> 34:06.770
Console.Writeline

310
34:11.570 --> 34:15.010
"Bitte geben Sie den Nachnamen des Studenten ein"

311
34:18.950 --> 34:26.060
var surname=console.readline();

312
34:26.190 --> 34:31.650
Jetzt müssen wir unsere SQL-Anweisung basierend auf den Vor- und Nachnamenvariablen aufbauen.

313
34:31.800 --> 34:37.520
var sql = string.format(

314
34:39.960 --> 34:44.660
"Einfügen in Studenten (Vorname, Nachname) ....

315
34:49.290 --> 35:00.490
Werte ('{0}','{1}')

316
35:01.360 --> 35:02.370
{0} und {1} sind Platzhalter für unsere beiden Variablen.

317
35:02.730 --> 35:08.320
Und wir werden in unserem Vor- und Nachnamen übergeben.

318
35:09.240 --> 35:16.320
Dies wird also unsere SQL-Zeichenfolge aufbauen; Ich habe in der Übung erwähnt, so dass dies belastbar sein muss

319
35:16.510 --> 35:24.570
SQL-Injektionsangriffe; die an dieser Stelle sehr wichtig ist, weil - man könnte sich vorstellen, wenn jemand

320
35:24.570 --> 35:33.690
würden eintippen - Name des Schülers ist - ' Drop Table Studenten - es wird unsere Studenten ruinieren

321
35:33.690 --> 35:34.590
Tabelle.

322
35:34.590 --> 35:39.840
Was ich also tun werde, ist, alle Apostrophe durch doppelte Apostrophe zu ersetzen, was bedeutet, dass wir immer noch

323
35:39.840 --> 35:45.990
unterstützen Apostrophe in unseren Studentennamen, erlauben aber keine entflohenen Injektionsangriffe.

324
35:45.990 --> 35:56.300
Vorname = vorname.replace("'","''"");

325
35:57.700 --> 36:00.490
Und Das gleiche tun Sie mit dem Nachnamen.

326
36:00.590 --> 36:09.330
Sie sollten immer jedem vom Benutzer bereitgestellten Text entgehen; auch wenn Sie nicht glauben, dass Ihre Benutzer böswillig sein werden

327
36:09.690 --> 36:13.290
Menschen können Fehler machen, die Leute können diese Art von Sachen versuchen.

328
36:13.980 --> 36:17.860
OK, jetzt haben wir unsere SQL-Anweisung erstellt.

329
36:18.000 --> 36:29.250
Wir erstellen jetzt ein neues SQLCommand-Objekt

330
36:29.250 --> 36:32.890
und übergeben Sie die SQL-Anweisung und die Verbindung.

331
36:33.990 --> 36:42.930
Jetzt führen wir eine Nicht-Abfrage aus, um zu sagen, dass wir keine Rückgabewerte benötigen oder keine Rückgabewerte haben. da es sich um ein Einfügen handelt

332
36:42.930 --> 36:48.840
Erklärung; keine Lektüre; und schließen Sie die Verbindung oder warten Sie einfach.

333
36:49.700 --> 36:53.020
Also rettet das; führen; Warten Sie, bis es erstellt wurde;

334
37:17.730 --> 37:21.530
OK geben Sie den Vornamen des Studenten ein, den ich John Boyle nennen werde.

335
37:21.540 --> 37:28.750
Also Johannes; Nachname Boyle; Geben Sie ein;

336
37:29.630 --> 37:30.300
Okay.

337
37:30.600 --> 37:37.920
Das hätte also laufen müssen; schauen Sie sich unsere Studententabelle an; und wir können einen neuen Studenten mit dem Namen sehen

338
37:37.920 --> 37:38.720
John Boyle.

339
37:38.790 --> 37:40.770
Es gibt kein Geburtsdatum; weil das nicht zur Verfügung gestellt wurde.

340
37:42.060 --> 37:49.220
So funktioniert die Lösung für .net. und wir werden weitermachen und einen Blick auf den Knoten als nächstes werfen

341
37:52.420 --> 37:59.290
Und jetzt werden wir zeigen, wie diese Übung mit Node zu lösen; wenn Sie sich entschieden haben, Knoten zu verwenden, um

342
37:59.890 --> 38:00.740
diese Übung durchführen.

343
38:01.360 --> 38:10.560
Um also Eingaben vom Benutzer zu sammeln, empfehle ich die Verwendung eines NPM-Pakets namens prompt-sync.

344
38:10.580 --> 38:16.420
Es gibt andere Pakete, die Sie verwenden können, aber ich finde prompt-sync sehr nützlich und ziemlich einfach zu

345
38:16.420 --> 38:16.740
Verwenden.

346
38:17.290 --> 38:22.090
Wir werden also damit beginnen; npm prompt-sync hinzufügen

347
38:22.210 --> 38:31.690
Denken Sie, dass dies eine synchrone Möglichkeit ist, Eingaben vom Benutzer zu sammeln, sodass Sie diesen Befehl ausführen und

348
38:31.900 --> 38:36.370
und es schließt es in unser Projekt ein.

349
38:36.400 --> 38:42.320
Wir gehen zurück zu unserem Lieblings-Texteditor, ich verwende edit plus öffnen Sie unseren index.js

350
38:43.060 --> 38:50.650
Wir importieren und das Prompt-Modul

351
38:55.530 --> 39:00.270
var-Eingabeaufforderung = require("prompt-sync")

352
39:01.470 --> 39:03.610
Jetzt haben wir also ein promptes Objekt.

353
39:03.600 --> 39:10.230
Jetzt bekommen wir einen Vornamen. 

354
39:16.550 --> 39:22.180
var vorname = prompt('Bitte geben Sie den Vornamen des Schülers ein:');

355
39:22.360 --> 39:34.440
Wir müssen dem Apostroph entkommen, nur ein Umgekehrter. 

356
39:34.740 --> 39:36.050
var nachname = prompt ('Was ist der Nachname des Studenten:');

357
39:39.270 --> 39:39.710
var nachname = prompt ('Was ist der Nachname des Studenten:');

358
39:42.790 --> 39:44.990
Jetzt; im Rahmen dieser Übung,

359
39:45.000 --> 39:50.640
Wir sagten, dass wir sicherstellen wollten, dass dies immun gegen SQL-Injektionsangriffe war, die effektiv

360
39:50.640 --> 39:54.060
bedeutet, dass wir alle Apostrophe durch doppelte Apostrophe ersetzen müssen.

361
39:54.640 --> 40:08.430
In JavaScript wird dies wie folgt ausgeführt:

362
40:08.490 --> 40:15.110
vorname=vorname.replace(/'/g,"''");

363
40:15.400 --> 40:20.930
Dieses Format hier /'/g deklariert tatsächlich einen Regex

364
40:21.690 --> 40:30.120
Der Grund, warum wir es nicht so tun; ist, dass diese spezielle Anweisung das erste Auftreten entfernen würde

365
40:30.240 --> 40:34.070
eines Apostrophs, aber nicht nachfolgenden Vorkommen eines Apostrophs.

366
40:34.080 --> 40:40.060
Dadurch werden alle Apostrophe entfernt, alle Apostrophe und doppelte Apostrophe ersetzt.

367
40:40.060 --> 40:43.280
Wir werden nicht das gleiche für Nachnamen tun.

368
40:44.120 --> 40:44.940
Und...

369
40:45.150 --> 40:53.790
Das sollte uns vor SQL-Injektionsangriffen schützen, jetzt werden wir unsere SQL-Anweisung schreiben

370
40:53.910 --> 40:57.360
in die Schülerwerte (Firsname,Name) werte (

371
41:00.180 --> 41:16.290
''Vorname'''''''Nachname'') 

372
41:16.360 --> 41:17.190
''Vorname'''''''Nachname'') 

373
41:18.660 --> 41:21.960
''Vorname'''''''Nachname'') 

374
41:22.350 --> 41:29.620
''Vorname'''''''Nachname'') 

375
41:29.860 --> 41:34.950
Wir müssen keinen Datensatz durchlaufen, da wir keinen für eine Insert-Anweisung zurückbekommen.

376
41:34.990 --> 41:36.850
Wir schreiben einfach das Wort console.log(

377
41:36.890 --> 41:37.650
"OK"

378
41:37.690 --> 41:39.850
Zu wissen, dass dies zurückgerufen hat.

379
41:40.340 --> 41:42.360
Wir checken die Datenbank anschließend ein.

380
41:42.580 --> 41:44.890
Das rettete;

381
41:44.920 --> 41:49.370
Wir werden den Knoten index.js ausführen

382
41:50.360 --> 41:51.780
Wir sagen Paul

383
41:54.620 --> 41:55.180
Murphy.

384
41:56.880 --> 42:03.350
OK; und wir überprüfen jetzt die Datenbank, um zu sehen, ob dies richtig eingefügt wurde.

385
42:03.350 --> 42:09.470
Wählen Sie * von Studenten; da gehen wir; wir haben Paul Murphy; Geburtsdatum ist null, weil wir nicht

386
42:09.470 --> 42:11.720
ein Geburtsdatum, aber das ist unsere Zeile.

387
42:14.760 --> 42:17.670
Und hier ist die Lösung für Python.

388
42:17.670 --> 42:24.690
Wenn Sie sich entschieden haben, Python als Programmiersprache zu verwenden, um diese Übung zu lösen, so sofort

389
42:25.650 --> 42:33.260
in unseren Code-Editor gehen; wir müssen einen Vor- und Nachnamen vom Benutzer sammeln.

390
42:33.870 --> 42:49.660
Vorname = Eingabe("Was ist der Vorname des Schülers?")

391
42:49.840 --> 43:00.280
Nachname = Eingabe("Was ist der Nachname des Studenten")

392
43:00.370 --> 43:06.050
Nun, als Teil dieser Übung, habe ich gebeten, sicherzustellen, dass dies vor SQL-Injektionsangriffen sicher ist, was effektiv bedeutet, dass wir einzelne Apostrophe durch

393
43:06.060 --> 43:11.290
doppelte Apostrophe für den Fall, dass der Benutzer versuchen sollte, etwas Böses einzureichen.

394
43:11.290 --> 43:21.010
Vorname = vorname.replace("'","''")

395
43:21.220 --> 43:26.020
und wir sollten dasselbe für Nachnamen tun

396
43:30.530 --> 43:38.690
jetzt ändern wir die Execute-Anweisung in

397
43:42.470 --> 43:44.420
in die Werte der Schüler (Vorname, Nachname) (...

398
43:47.560 --> 43:54.690
wir sollten hier Inhaber für den Vornamen einsetzen; und ein Platzhalter für den Nachnamen

399
43:58.210 --> 44:04.810
.format(Vorname, Nachname)

400
44:07.590 --> 44:17.230
und bevor das tatsächlich funktionieren wird, müssen wir die Verbindung so festmachen; wir haben keinen Cursor, also

401
44:17.230 --> 44:20.430
wir werden nur print("OK") sagen

402
44:23.500 --> 44:35.410
OK, wir speichern dies; Kehren Sie zurück in die Eingabeaufforderung, und geben Sie Python script.py

403
44:35.500 --> 44:40.490
Vorname John, Nachname Boyle.

404
44:40.790 --> 44:41.210
Okay.

405
44:42.250 --> 44:51.090
* von den Studenten auswählen; Schauen Sie in die Datenbank und wir haben John Boyle als neuen Studenten

406
44:51.090 --> 44:58.470
Und schließlich, wenn Sie Java als Ihre Sprache Ihrer Wahl gewählt haben, um diese Übung abzuschließen, ist die Anleitung für

407
44:58.470 --> 45:02.680
wie diese Lösung mit Java zu lösen.

408
45:02.960 --> 45:09.260
Also, was wir tun, ist zurück in unseren Text-Editor gehen und öffnen Sie die SQLJava.java-Programm, das wir hatten

409
45:09.270 --> 45:10.950
früher geschrieben.

410
45:11.060 --> 45:19.900
Um also Benutzereingaben aus der Befehlszeile in Java zu sammeln, werden wir eine Klasse namens Scanner verwenden.

411
45:20.960 --> 45:23.630
Was wir also zuerst importieren müssen, ist, sie zu importieren.

412
45:23.630 --> 45:28.730
java.util.Scanner importieren;

413
45:31.400 --> 45:32.210
wir werden

414
45:36.680 --> 45:40.510
unser Scannerobjekt deklarieren;  Scannerscanner = neuer Scanner (System.in);

415
45:41.150 --> 45:55.290
So erstellen wir einen Scanner aus dem Standardeingang, d.h. der Textschnittstelle.

416
45:55.460 --> 46:00.490
Jetzt werden wir eine Erklärung schreiben, die besagt, dass sie in den Vornamen des Schülers eingeht.

417
46:00.590 --> 46:06.230
System.out.printLn("

418
46:07.010 --> 46:11.740
"Geben Sie den Vornamen des Schülers ein:");

419
46:15.290 --> 46:19.820
und dann werden wir die Eingabe vom Scanner sammeln.

420
46:19.850 --> 46:29.750
Zeichenfolgenvorname = Scanner.nextLine();

421
46:31.550 --> 46:34.520
Was alles bis zum nächsten Eintrag bringt, wie in, wenn der Benutzer die Eingabe drückt.

422
46:34.520 --> 46:41.360
Jetzt wie zuvor und ich habe Sie gebeten, sicherzustellen, dass dies widerstandsfähig gegen SQL-Injektionsangriffe ist

423
46:41.390 --> 46:47.640
was nur bedeutet, dass Sie den Apostrophen entkommen und Apostrophe durch doppelte Apostrophe ersetzen müssen.

424
46:47.900 --> 46:48.860
So einfach ist das.

425
46:48.880 --> 46:53.420
Um dies in Java zu tun, verwenden wir:

426
46:57.410 --> 47:06.530
Vorname = firname.replace("'","''"");

427
47:06.530 --> 47:07.770
Und wir werden jetzt dasselbe für den Nachnamen tun.

428
47:07.770 --> 47:17.580
Kopieren Sie dann diese drei Codezeilen und ändern Sie sie bei Bedarf. Nachname des Studenten, Nachname der Zeichenfolge.

429
47:18.050 --> 47:20.660
scanner.newLine()

430
47:21.800 --> 47:26.730
Und wir ersetzen die invertierten Kommas.

431
47:27.710 --> 47:36.440
Was wir jetzt tun müssen, ist, dass wir unsere SQL-Anweisung erstellen, damit wir string.format verwenden, weil

432
47:36.530 --> 47:40.640
Ich werde hier einige Platzhalter verwenden

433
47:45.030 --> 47:48.180
String.format("Einfügen in Studenten (Vorname, Nachname) Werte ( ...

434
47:51.960 --> 48:06.210
'%s','%s')",Vorname,Nachname);

435
48:06.900 --> 48:09.140
'%s','%s')",Vorname,Nachname);

436
48:12.550 --> 48:17.170
Wenn dieser ausgeführt wird, wird der Vorname in den ersten %s 

437
48:17.170 --> 48:17.960
Nachname geht in die zweite %s

438
48:24.340 --> 48:30.610
Wir verwenden stmt.execute und übergeben die SQL

439
48:30.760 --> 48:42.200
Jetzt wird dies nicht ergebnisseset zurückgeben, also werden wir dies loswerden; und das brauchen wir nicht.

440
48:42.380 --> 48:44.470
Vielleicht möchte ich einen Ausdruck.

441
48:44.720 --> 48:49.200
Okay zu sagen, dass die Anweisung ausgeführt wurde.

442
48:51.070 --> 48:51.510
Und..

443
48:51.550 --> 48:52.510
...

444
48:52.580 --> 48:53.990
Das sollte vorerst der Nachsehen haben.

445
48:53.990 --> 49:03.950
Wir werden dies speichern; kompilieren; und führen Sie es; so zurück in die Eingabeaufforderung; wir werden eintippen

446
49:04.860 --> 49:06.830
javac SQLJava.java

447
49:06.830 --> 49:07.270
javac SQLJava.java

448
49:10.380 --> 49:10.760
Okay.

449
49:10.780 --> 49:12.990
Es ist korrekt kompiliert.

450
49:13.020 --> 49:23.010
java -cp ".; sqljdbc42.jar" SQLJava

451
49:23.310 --> 49:31.240
java -cp ".; sqljdbc42.jar" SQLJava

452
49:32.520 --> 49:35.050
Vorname: Peter.

453
49:35.670 --> 49:37.180
Nachname: Doyle.

454
49:39.240 --> 49:41.510
Und es kehrt mit ... Okay

455
49:41.630 --> 49:48.950
Gehen wir zurück in die Datenbank und wir werden "aus * von den Studenten auswählen"

456
49:48.950 --> 49:50.300
Da ist Peter Doyle.

457
49:51.110 --> 49:55.100
Das ist also die Lösung in Java.

458
49:55.370 --> 49:56.190
Das ist alles Leute.

459
49:56.330 --> 49:58.070
Vielen Dank, dass Sie diesen Kurs verfolgt haben.

460
49:58.070 --> 50:01.940
Ich hoffe, Sie haben viel daraus gelernt und haben das Gefühl, dass Sie SQL Server jetzt gemeistert haben.

461
50:01.940 --> 50:06.700
Wenn Sie von uns a