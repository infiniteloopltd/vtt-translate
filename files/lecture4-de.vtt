WEBVTT

0
00:01.110 --> 00:10.260
Erweiterte Abfragen; tiefer in die ausgewählte Aussage eintauchen. 

1
00:10.260 --> 00:12.520
Und / oder wenn Sie Daten zurückgeben möchten, die mehr als ein Kriterium erfüllen.

2
00:12.900 --> 00:20.460
Sie können den bewaffneten Operator verwenden, um anzugeben, dass beide Kriterien erfüllt sind, oder um anzugeben, dass ein Kriterium

3
00:20.520 --> 00:21.500
erfüllt ist.

4
00:21.660 --> 00:26.340
Vielleicht möchte eine Bank nach ungewöhnlichen Kontosalden mit Abfragen wie:

5
00:26.340 --> 00:31.740
Wählen Sie * aus bankAccount, wo Saldo > 1000000 und Alter 12

6
00:31.740 --> 00:33.440
oder; Wählen Sie * von bankkonto, wobei Alter 1 oder Alter >100

7
00:33.490 --> 00:38.430
Video-Demonstration.

8
00:38.430 --> 00:42.620
Hier werden wir demonstrieren und oder Klauseln, um folgendes zu erreichen.

9
00:42.780 --> 00:45.670
Suchen Sie Schüler mit dem Namen Mary Smith.

10
00:45.930 --> 00:51.160
Finde Studenten namens Peter oder mit dem Nachnamen Smith.

11
00:51.570 --> 00:55.720
OK, also sind wir hier wieder in SQL Server Management Studio.

12
00:55.760 --> 01:01.850
Unsere Aufgabe ist es, Schüler namens Mary Smith zu finden oder Schüler namens Peter oder mit dem Nachnamen Smith zu finden.

13
01:02.600 --> 01:03.820
Werfen wir also einen Blick auf unsere Studenten.

14
01:12.040 --> 01:18.980
Um also Studenten mit dem Namen Mary and Smith zu finden, müssen wir die Vornamenspalte und den Nachnamen abfragen.

15
01:19.000 --> 01:32.460
Spalte der Buchstabe, in dem Klausel Vorname = 'Maria' und Nachname = 'Schmied'

16
01:32.760 --> 01:34.870
Dadurch wird wie erwartet eine Zeile zurückgegeben.

17
01:36.360 --> 01:44.130
Unsere zweite Aufgabe ist es, Studenten namens Peter oder mit dem Nachnamen Smith so zu finden; Wählen * von Studenten

18
01:45.420 --> 01:55.240
wobei Vorname='Peter' oder nachname='Smith'

19
01:58.440 --> 02:03.090
Dadurch werden zwei Zeilen in der ersten Zeile zurückgegeben, da ein Nachname Smith ist.

20
02:03.180 --> 02:07.220
Zweite Zeile, weil der Vorname Peter ist.

21
02:07.550 --> 02:10.230
Mehr als weniger als gleich oder nicht gleich.

22
02:11.090 --> 02:16.540
Sie können die folgenden Operatoren verwenden, um Dinge mehr als, kleiner als, gleich oder nicht gleich zu vergleichen.

23
02:16.580 --> 02:23.210
Wenn der Operator auf Text angewendet wird, bezieht er sich auf die Wörterbuchreihenfolge von Wörtern, d. h.  Hund würde nach Katze erscheinen

24
02:23.210 --> 02:26.680
Video-Demonstration.

25
02:26.690 --> 02:33.410
Hier zeigen Gleichheits- und Vergleichsoperatoren Bücher mit mehr als 450 Seiten, 

26
02:33.410 --> 02:41.300
weniger als 400 Seiten, genau 413 Seiten oder nicht 413 Seiten.

27
02:41.310 --> 02:43.940
Hier werden wir einige Vergleichsoperatoren demonstrieren.

28
02:44.090 --> 02:50.180
Also wollen wir nach Büchern mehr als 400 Seiten, weniger als 400 Seiten, genau 413, suchen. 

29
02:50.870 --> 02:51.530
und haben keine 413 Seiten

30
02:52.250 --> 02:54.470
So wählen wir aus Bücher Tabelle

31
02:59.110 --> 03:04.690
und wir können einfach sagen, wo Seiten mehr als 400

32
03:09.380 --> 03:15.070
gibt zurück, dass nicht weniger als 400 das andere Buch zurückgibt

33
03:17.850 --> 03:21.810
entspricht 413

34
03:21.810 --> 03:27.420
oder nicht gleich 413, gibt diese beiden Bücher zurück

35
03:30.860 --> 03:36.930
wie Operator;  Beim Textvergleich können Sie den like-Operator verwenden, um Textmuster mit dem Prozentsatz zu vergleichen,

36
03:36.930 --> 03:42.620
Ortshalter, um fehlenden Text anzugeben, z. B. zu einer Liste von Schülern, bei denen Maria Teil ihrer

37
03:42.620 --> 03:43.230
Namen.

38
03:43.310 --> 03:46.070
Also nur Mary und Mary Jane und Amaryah.

39
03:46.340 --> 03:51.050
Dies wird als geschrieben werden; Wählen Sie * von Schülern aus, bei denen Vorname wie '%Mary%'

40
03:51.050 --> 03:56.610
Video-Demonstration.

41
03:56.850 --> 04:01.820
Hier zeigen wir die Verwendung des ähnlichen Operators, um die folgende Liste von

42
04:01.830 --> 04:10.090
Name beginnt mit dem Buchstaben M und listet alle Bücher auf, die Harry Potter und den Titel enthalten.

43
04:10.210 --> 04:13.570
Dies ist, wo es die Verwendung des ähnlichen Betreibers demonstrieren wird.

44
04:13.660 --> 04:19.610
Wir listen alle Schüler auf, deren Name mit dem Buchstaben M beginnt, und dann listen wir alle Bücher auf, die

45
04:19.610 --> 04:20.410
Harry Potter im Titel.

46
04:21.050 --> 04:22.960
Schauen wir uns unsere Studententabelle an

47
04:29.630 --> 04:40.440
so gibt es zwei Studenten beginnend mit M. Beide Marys. wobei Vorname wie 'M%' 

48
04:41.050 --> 04:45.050
Also beginnen wir mit dem Buchstaben M, gefolgt von allem anderen.

49
04:45.070 --> 04:51.810
Deshalb haben wir die beiden Marias. Bücher, die Harry Potter im Titel enthalten, 

50
04:51.950 --> 04:52.420
Auswählen * aus Büchern 

51
04:58.810 --> 05:01.510
es muss nicht unbedingt mit dem Wort Harry Potter beginnen.

52
05:01.780 --> 05:08.860
So sagen wir; 

53
05:09.190 --> 05:11.090
wobei Buchname wie '%Harry Potter%'

54
05:11.230 --> 05:12.070
wobei Buchname wie '%Harry Potter%'

55
05:12.100 --> 05:17.200
Das bedeutet, dass Harry Potter überall im Buchnamen erscheinen kann

56
05:23.280 --> 05:29.490
Wählen Sie einen eindeutigen Operator aus, wenn Sie exakte Duplikate aus einem Abfrageergebnis verschieben möchten, mit dem wir

57
05:29.490 --> 05:30.750
einen eindeutigen Operator.

58
05:31.110 --> 05:35.920
Zum Beispiel, wenn Sie alle eindeutigen Geburtsdaten von Studenten sehen möchten, wird es sein;

59
05:35.930 --> 05:41.030
Wählen Sie verschiedene DateOfBirth von Studenten

60
05:41.060 --> 05:47.230
Wird die Verwendung eines ausgewählten eindeutigen Operators demonstrieren, um die folgende Liste zu erreichen;

61
05:47.230 --> 05:51.440
alle Vornamen des Schülers ohne Duplikate auflisten.

62
05:51.830 --> 05:57.710
Hier demonstrieren wir SELECT DISTINCT, indem wir alle Vornamen aller Schüler ohne Duplikate auflisten.

63
05:57.780 --> 05:59.430
Werfen wir also einen Blick auf unsere Studententabelle

64
06:06.030 --> 06:08.700
die sich speziell um den Vornamen kümmern.

65
06:09.980 --> 06:14.700
Spalte

66
06:14.950 --> 06:17.660
Sie können sehen, dass wir zwei Marias und einen Petrus haben, also sage ich;

67
06:17.710 --> 06:22.300
SELECT DISTINCT.

68
06:22.360 --> 06:25.260
Dann bekommen wir eine Maria und Petrus.

69
06:25.330 --> 06:31.450
Nun sind Sie vielleicht neugierig, warum ich den Vornamen angegeben habe, anstatt stern auszuwählen.

70
06:32.310 --> 06:39.550
Ich sehe, dass dies keine Auswirkungen hat, weil es andere Spalten gibt, die eindeutig sind, wie z. B. ein Nachname

71
06:39.610 --> 06:45.190
oder die I.D. Die richtige Lösung ist also, den Vornamen von den Kursteilnehmern zu unterscheiden.

72
06:47.840 --> 06:55.160
Sortieren von Daten: Standardmäßig sind Daten, die von select-Anweisung zurückgegeben werden, keine garantierte Reihenfolge. Um nach einem zu bestellen

73
06:55.160 --> 07:03.980
Spalte in aufsteigender Reihenfolge verwenden Sie die Reihenfolge nach und für absteigende Reihenfolge verwenden Sie die Reihenfolge von DESC für einen zufälligen Shuffle.

74
07:04.080 --> 07:13.310
Bestellen Sie nach newid(), um Studenten nach Nachnamen zu bestellen 

75
07:13.310 --> 07:18.480
Wählen * von Studenten nach Nachnamen bestellen

76
07:18.480 --> 07:23.370
Wenn wir also alle vergangenen Themen zusammensetzen, werden wir eine komplexe Abfrage demonstrieren, die eine Liste

77
07:23.370 --> 07:31.350
Buchnamen, die entweder von Dhonielle Clayton geschrieben wurden oder über 400 Seiten lang sind und die Ergebnisse bringen

78
07:31.500 --> 07:34.670
Alphabetisch.

79
07:35.460 --> 07:41.690
OK also, indem wir das, was wir bisher gelernt haben, kombinieren, werden wir eine komplexe Abfrage schreiben, die Buchnamen auflistet

80
07:41.690 --> 07:49.070
die entweder von Danielle Clayton geschrieben wurden oder über 400 Seiten lang sind, und wir wollen das Ergebnis bestellen

81
07:49.080 --> 07:49.650
Alphabetisch.

82
07:51.130 --> 07:54.510
Schauen wir uns also unsere Büchertabelle an

83
07:59.570 --> 08:10.090
, damit der Autor sich dem in der Tabelle des Buchautors und der Autoren anschließt.

84
08:12.510 --> 08:22.620
bookAuthor ba auf ba.bookid = b.id autor ein auf a.id = ba.authorid beitreten

85
08:23.090 --> 08:24.390
Alles klar.

86
08:24.590 --> 08:29.390
Aus der früheren Lektion sollten Sie sich an die vielen bis vielen Beziehungen erinnern, die wir zwischen Büchern haben

87
08:29.420 --> 08:40.800
und Buchautoren, deshalb haben wir jetzt Buchnamen und Autorennamen Ich möchte dies auf Autoren beschränken

88
08:43.760 --> 08:46.670
"Dhonielle Clayton" genannt

89
08:53.030 --> 09:02.820
oder Seiten mehr als 400.

90
09:02.930 --> 09:05.120
Jetzt haben wir ein Duplikat in der Liste.

91
09:05.390 --> 09:08.740
Alles, was uns interessiert, sind die Buchnamen.

92
09:14.950 --> 09:19.610
zwei Bücher, aber ein doppelter Schlüssel für den Mehrfachautor

93
09:20.270 --> 09:21.500
So wählen Sie unterschiedliche

94
09:27.110 --> 09:32.090
und um diese alphabetisch zu bestellen, sagen Sie Bestellung nach Buchname

95
09:41.180 --> 09:48.350
Datumsoperationen; Bestimmte Vorgänge sind spezifisch für die Datentypen Datum oder Datumszeit, z. B.: Tag(): der Tagesteil des Datums

96
09:48.350 --> 09:50.330
Monat(): der Monatsteil des Datums

97
09:50.370 --> 09:54.030
Jahr(): der Jahresteil des Datums.

98
09:54.640 --> 09:59.090
Und für eine flexiblere Bedienung; ist datepart, das zwei Parameter akzeptiert.

99
09:59.090 --> 10:06.230
Das Intervall und das Datum; und dies gibt einen Teil des durch das Intervall angegebenen Datums zurück. 

100
10:06.500 --> 10:08.210
Das Intervall kann Tag, Monat, Jahr,

101
10:08.240 --> 10:11.810
Stunde, Minute, TagOfYear, Wochentag und so weiter.

102
10:13.090 --> 10:22.560
Um das heutige Datum zu erhalten, können Sie wählen getdate()

103
10:22.910 --> 10:27.480
Hier zeigen wir einige Datumsoperationen; das heutige Datum zu erhalten.

104
10:27.770 --> 10:34.860
Abrufen des aktuellen Monats; Abrufen des aktuellen Datums; und die Anzahl der Tage seit Beginn der

105
10:34.860 --> 10:35.130
Jahr.

106
10:38.100 --> 10:41.170
Hier werden einige Datumsoperationen gezeigt; das heutige Datum zu erhalten.

107
10:41.220 --> 10:45.690
Abrufen des aktuellen Monats; den aktuellen Tag zu bekommen; und die Anzahl der Tage seit Beginn der

108
10:45.690 --> 10:46.830
Jahr.

109
10:46.890 --> 10:52.380
Dieses Video wird am 20. November 2019 vorbereitet.

110
10:52.680 --> 10:54.820
Ihre Ergebnisse werden natürlich in der Zukunft sein.

111
10:56.020 --> 10:56.930
wählen Getdate()

112
11:01.200 --> 11:03.240
dies gibt das aktuelle Datum von heute zurück.

113
11:06.060 --> 11:18.000
Der aktuelle Monat, der ein 11. November Monat sein würde, ist der Tag mit ist der 20.

114
11:18.000 --> 11:19.930
die Anzahl der Tage seit Jahresbeginn.

115
11:19.950 --> 11:25.880
Wir haben das Wort datepart und dayofyear verwendet.

116
11:25.950 --> 11:34.190
Operator und dies gibt 324 zurück, da dies die Anzahl der Tage seit dem 1. Januar ist.

117
11:35.740 --> 11:44.830
Textoperationen; bestimmte Vorgänge sind spezifisch für Char-, Varchar- und Nvarchar-Datentypen, z. B.:

118
11:45.250 --> 11:51.690
reverse() - kehrt die Reihenfolge der Zeichen um; Len() - erhält die Länge des angegebenen Textes; substring() - Extrahieren Sie Text aus größerem Text

119
11:51.760 --> 11:59.320
charindex() - finden Sie Text im größeren Text; und viele andere Operationen 

120
11:59.320 --> 12:01.240
Ich empfehle, auf der Microsoft-Website für die vollständige Liste zu sehen

121
12:04.130 --> 12:05.690
Video-Demonstration.

122
12:05.690 --> 12:13.240
Hier zeigen wir einige Textoperationen; Umkehren eines Textes; Abrufen der Länge eines Textes

123
12:13.240 --> 12:21.200
eine Liste der Studenten als erste Initiale mit folgendem Nachnamen zurückgeben; Die Harry Potter-Bücher nur nach Untertiteln auflisten

124
12:24.070 --> 12:30.750
hier werden wir einige Textoperationen speziell demonstrieren; Umkehren eines Textes; Die Länge erhalten

125
12:30.750 --> 12:36.390
von text; kehren Sie alle Schüler zuerst zuerst gefolgt von Nachnamen und listen sie die Harry Potter Bücher auf

126
12:36.390 --> 12:37.380
nur nach Untertitel

127
12:38.340 --> 12:54.390
Lassen Sie uns also zuerst einen Blick auf eine einfache werfen; wählen Sie umgekehrt ('lived') rückwärts Zauber Teufel; Länge des Textes;

128
12:55.650 --> 12:59.080
len ("hallo") ist ein Wort aus fünf Buchstaben.

129
12:59.180 --> 13:03.260
Nun eine Liste der Studenten zuerst zuerst gefolgt von Nachnamen; Schauen wir uns unsere Schülertabelle an

130
13:08.040 --> 13:18.160
Wir wollen die erste Initiale, die wir substring Befehl Vorname der erste Parameter ist die Zahl

131
13:18.250 --> 13:22.680
von links einzeichenweise; Eine.

132
13:22.780 --> 13:31.580
Wie viele Zeichen Möchten Sie nehmen, welche ist eine; Das gibt also ein M für Maria und ein P für Petrus.

133
13:32.590 --> 13:36.020
Fügen Sie einen Punkt, leer und den Nachnamen hinzu

134
13:40.740 --> 13:50.220
das macht also einen M Smith von Mary Smith und einen P Murphy von Peter Murphy; jetzt lässt harry Potter anschauen

135
13:50.220 --> 13:51.550
Bücher nur nach Untertiteln.

136
13:51.720 --> 13:53.010
Schauen wir uns also unsere Bücher an

137
13:58.750 --> 14:00.610
also wollen wir nur Harry Potter Bücher.

138
14:00.610 --> 14:07.330
Sagen Sie also, wo Buchnamen wie 'Harry Potter%'

139
14:11.750 --> 14:12.390
jetzt.

140
14:12.550 --> 14:17.480
Der Untertitel hier wird Kammer des Geheimnisses für dieses Buch Gefangen er von Azkaban für dieses Buch sein.

141
14:18.830 --> 14:23.450
Wir müssen also den Speicherort dieses Textes im Buchnamen finden.

142
14:24.620 --> 14:29.980
In welchem Fall werde ich tatsächlich nach dem Wort suchen und dem, weil es beiden gemeinsam ist.

143
14:30.140 --> 14:31.880
Also verwenden wir den charindex

144
14:34.540 --> 14:40.460
das Bit an Text, den wir suchen, und Platz und den Buchnamen.

145
14:40.750 --> 14:41.620
Das ist die Spalte.

146
14:43.180 --> 14:51.050
Wenn wir dies ausführen, werden wir sehen, dass der Untertitel auf dem 14. Zeichen im ganzen Buch erscheint.

147
14:52.210 --> 14:55.510
Wir werden dies also mit dem Wort Substring kombinieren

148
14:58.580 --> 15:12.410
Buchname die Position, die 14 sein wird und die Länge, die wir maximal 400 nehmen werden.

149
15:12.560 --> 15:18.680
Also, wie wir dies laufen Wir können sehen, dass es tatsächlich zurückgegeben und die Kammer der Geheimnisse.

150
15:18.680 --> 15:26.450
Vielleicht, wenn wir nicht wollen, dass sie erscheinen, können wir ein plus Len('und die ') hinzufügen

151
15:29.340 --> 15:29.830
Noch einmal.

152
15:31.060 --> 15:39.620
Jetzt haben wir also eine Kolumne mit den Untertiteln drin.

153
15:40.490 --> 15:45.380
Wenn Sie eine Abfrage schreiben, bei der die Spalte in der SELECT-Anweisung ein berechneter Wert ist, wird die Spalte

154
15:45.380 --> 15:46.560
keinen Namen haben.

155
15:46.910 --> 15:50.330
Sie können es zuweisen, indem Sie AS dann einen Spaltennamen schreiben

156
15:50.420 --> 15:56.720
Wenn wir z. B. eine Spalte mit dem vollständigen Namen des Schülers wollten, konnten wir 

157
15:56.760 --> 16:04.850
Vorname + ' ' + Nachname als Vollname von Studenten auswählen 

158
16:04.850 --> 16:09.540
Sie können einer Spalte auch einen neuen Namen mit einem Spaltenalias zuweisen, wenn dies z. B. im Kontext sinnvoller ist.

159
16:09.560 --> 16:17.840
SELECT DISTINCT Nachname als Familienname von Student 

160
16:17.840 --> 16:27.780
Wir demonstrieren einen Spaltenalias, indem wir eine Liste von Schülern mit einem kombinierten Vor- und Nachnamen auf den spaltennamen vollständigen Namen zurückgeben.

161
16:28.170 --> 16:33.690
Um COLUMN ALIAS zu demonstrieren, möchten wir nun eine Liste von Schülern mit kombiniertem Vornamen und

162
16:33.690 --> 16:37.390
Nachname unter der Spalte Vollname

163
16:42.440 --> 16:53.850
Wir kombinieren ihren Vor- und Nachnamen.

164
16:53.960 --> 16:55.800
Beachten Sie, dass dies noch keinen Spaltennamen hat.

165
16:56.600 --> 16:59.450
Wir nennen es also als vollständigen Namen

166
17:02.910 --> 17:05.120
und wieder können Sie sehen, dass die Spalte jetzt einen Namen hat.

167
17:06.900 --> 17:14.140
Subabfragen; manchmal benötigen Sie einen Abfragefilter für Ergebnisse aus einer anderen Abfrage.

168
17:14.220 --> 17:17.040
Diese Art von Auswahlabfragen sind im folgenden Formular.

169
17:17.070 --> 17:24.470
SELECT * aus Tabelle1, in der X in (wählen Sie Y aus Tabelle2 )

170
17:24.480 --> 17:29.310
Dies würde bedeuten, dass Sie alle Zeilen aus Tabelle 1 oder Spalte X sehen möchten, die einem der Werte entsprechen.

171
17:30.030 --> 17:32.600
von Y aus Tabelle 2.

172
17:32.820 --> 17:35.990
Sie können die Funktion von in

173
17:39.000 --> 17:40.790
Video-Demonstration.

174
17:41.130 --> 17:50.330
Hier zeigen wir Unterabfrage; zurück zur Liste der Buchleihgaben für alle Bücher der Harry Potter-Serie.

175
17:50.560 --> 17:56.780
Hier wird eine Unterabfrage veranschaulicht. eine Liste der Buchausleihen für alle Bücher der Harry Potter-Serie zurückzugeben.

176
17:56.920 --> 17:59.470
Werfen wir also einen Blick auf unsere Bücher.

177
18:06.060 --> 18:06.530
Um.

178
18:06.690 --> 18:09.290
Wir wollen das auf Harry Potter-Bücher beschränken.

179
18:09.390 --> 18:15.340
Buchname wie Harry Potter.

180
18:20.590 --> 18:25.050
Wenn Sie eine Unterabfrage schreiben, sollten Sie nur eine Spalte zurückgeben.

181
18:25.990 --> 18:34.880
In diesem Fall möchte ich also die ID zurückgeben.

182
18:35.190 --> 18:41.130
Dies wird also die IDs zurückgeben, die mit beiden Harry Potter-Büchern verbunden sind.

183
18:41.140 --> 18:43.150
Werfen wir nun einen Blick auf unsere Bücher Leihtabelle.

184
18:50.180 --> 19:00.400
Und wenn wir dies auf Bücher beschränken würden, die in der nachfolgenden Abfrage enthalten sind, würden wir sie verwenden;

185
19:00.400 --> 19:06.040
wobei bookId in (

186
19:06.330 --> 19:07.080
Zweite Abfrage

187
19:10.790 --> 19:19.260
dies auszuführen; also schauen wir uns jetzt Buchleihe an, wo das Buch in der Liste der Bücher steht.

188
19:19.260 --> 19:29.450
Von Harry Potter; wir können dies umkehren, indem wir "nicht in" sagen, um null Ergebnisse zu erzielen; aber das ist unsere Antwort.

189
19:33.370 --> 19:40.090
Union; Wenn Sie schreiben würden, um Anweisungen auszuwählen und diese beide in einem Ergebnis kombinieren möchten, können Sie

190
19:40.090 --> 19:46.750
die Erklärung der Union zu nutzen; Wählen Sie X aus Tabellenunion aus Y aus Tabelle auswählen.

191
19:46.750 --> 19:51.850
Dies würde bedeuten, dass Sie sowohl Spalte X als auch Spalte y in einer Spalte im Ergebnis wünschen.

192
19:51.850 --> 19:58.760
Möglicherweise müssen Sie sicherstellen, dass Anzahl und Typ der Spalten übereinstimmen. 

193
19:58.760 --> 20:07.200
Hier demonstrieren wir in Einheit; Eine Liste der Autoren in Kombination mit einer Liste von Studenten oder nach Namen zurückgeben

194
20:07.200 --> 20:12.810
Hier werden wir eine Gewerkschaft demonstrieren; wobei wir eine Liste der Autoren und eine Liste der Studenten auswählen.

195
20:12.960 --> 20:15.380
Kombinieren Sie sie zusammen und bestellen Sie sie nach Namen.

196
20:16.140 --> 20:21.720
Werfen wir einen Blick auf unsere Autoren.

197
20:21.790 --> 20:28.790
Nehmen wir einfach den Namen des Autors von hier.

198
20:29.000 --> 20:30.110
Werfen wir einen Blick auf unsere Studenten

199
20:35.210 --> 20:36.250
Und

200
20:36.680 --> 20:38.420
Kombinieren wir Vor- und Nachnamen

201
20:49.650 --> 20:50.690
sie miteinander zu kombinieren;

202
20:51.030 --> 21:00.220
Wir können Union für diese jetzt die Autoren und die Studenten zurück schreiben.

203
21:00.230 --> 21:07.190
Nun, wenn wir dies bestellen wollen; wir können Ordnung nach Autorname sagen

204
21:11.920 --> 21:13.670
und schließlich ist es an dir vorbei.

205
21:14.450 --> 21:18.360
Basierend auf dem, was Sie in dieser Lektion gelernt haben, ist hier ein Test 

206
21:18.410 --> 21:26.680
Listen Sie Autoren auf, die denselben ersten Buchstaben ihres Nachnamens teilen, können Sie dieses Video jetzt anhalten und einmal fortsetzen

207
21:26.680 --> 21:33.510
Sie haben diesen Test versucht.

208
21:33.590 --> 21:35.880
OK, also hoffe ich, dass Sie das gegeben haben.

209
21:35.970 --> 21:37.120
Und wenn Sie es noch nicht getan haben.

210
21:37.120 --> 21:41.050
Dann können Sie dieses Video jetzt anhalten und fortsetzen, sobald Sie diesen Test versucht haben.

211
21:42.580 --> 21:44.550
OK, also hier sind wir.

212
21:44.640 --> 21:50.890
Wir möchten Autoren auflisten, die denselben ersten Buchstaben ihres Nachnamens mit einem anderen Autor teilen.

213
21:50.970 --> 21:53.280
Wenn wir also einen Blick auf die Autorentabelle werfen

214
21:59.300 --> 22:05.690
wir können sehen, dass diese beiden Autoren den gleichen ersten Buchstaben ihres Nachnamens teilen, aber

215
22:05.690 --> 22:10.810
um den ersten Buchstaben des Nachnamens zu extrahieren.

216
22:10.880 --> 22:18.230
Was wir tun müssen, ist, den Abstand zwischen Vor- und Nachnamen zu finden und den Buchstaben zu extrahieren, der

217
22:18.230 --> 22:19.900
folgt sofort dem Raum.

218
22:20.870 --> 22:24.070
Um also den Platz zu finden, sollten wir den charIndex verwenden.

219
22:24.090 --> 22:24.450
Alles klar

220
22:32.970 --> 22:39.360
So kehrt dies nun die Position des Raumes zurück, den wir jetzt wollen, den Buchstaben, der unmittelbar dem Raum folgt.

221
22:39.360 --> 22:46.560
Wir verwenden also ein Plus, das der Ort des ersten Buchstabens des Nachnamens sein wird, um

222
22:46.560 --> 22:48.360
den ersten Buchstaben des Nachnamens.

223
22:48.360 --> 22:55.940
Wir sollten die Teilzeichenfolge verwenden; Name des Autors; charIndex so weiter

224
23:02.120 --> 23:02.760
Ein Zeichen

225
23:05.860 --> 23:15.990
dies gibt nun R für Rowling, C usw. zurück. In der zweiten Abfrage, wie ich bereits erwähnte, sollte er also nur

226
23:15.990 --> 23:17.530
eine Spalte zurückgeben.

227
23:18.510 --> 23:21.690
Dies gibt nun alle

228
23:25.180 --> 23:28.450
Vorderbuchstaben der Nachnamen der Autoren.

229
23:28.720 --> 23:32.470
Das wird also die Grundlage unserer Unterabfrage bilden.

230
23:32.470 --> 23:39.040
Werfen wir nun einen Blick auf unsere Hauptabfrage.

231
23:39.350 --> 23:40.990
Jetzt unsere Hauptabfrage

232
23:43.570 --> 23:51.010
vergleicht erneut den ersten Buchstaben des Nachnamens mit dem der gleichen Abfrage.

233
23:51.010 --> 23:52.080
Wir werden es also nehmen.

234
23:52.150 --> 23:55.330
Dieser Ausdruck verwendet den Operator

235
23:59.010 --> 24:02.530
und vergleichen Sie sie mit der Unterabfrage.

236
24:02.630 --> 24:10.250
Bevor ich dies führe, sollte ich darauf hinweisen, dass, da die Unterabfrage den ersten Buchstaben jedes Autors zurückgibt.

237
24:10.250 --> 24:20.580
des Nachnamens und offensichtlich wird diese Abfrage jeden Autor zurückgeben, da jeder auch diesen Kriterien entsprechen würde.

238
24:20.830 --> 24:28.570
Daher muss ich zwischen dem in der Hauptabfrage genannten Verfasser und dem

239
24:28.630 --> 24:36.330
Autorentabelle, auf die in der Unterabfrage verwiesen wird, in welchem Fall ich eine Tabelle alias a1 und a2 verwenden kann

240
24:41.380 --> 24:48.910
in diesem Fall kann ich innerhalb der Unterabfrage unterscheiden, dass ich einen anderen Autor als den

241
24:48.910 --> 24:58.350
eine, auf die in der übergeordneten Abfrage verwiesen wird; s