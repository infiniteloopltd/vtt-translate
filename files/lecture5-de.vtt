WEBVTT

0
00:00.930 --> 00:09.570
Aggregierte Daten; Gruppieren von Daten; Aggregierte Datenabfragen; Daten fallen manchmal natürlich in Gruppen, in denen viele

1
00:09.570 --> 00:15.340
Zeilen können dieselben Merkmale aufweisen; Wenn Sie eine Datenbank mit den Daten der Personen aufbewahrt haben,

2
00:15.340 --> 00:20.830
dass Datenpunkte wie Name und Anschrift einigermaßen eindeutig sind, wenn Staatsangehörigkeit und Geschlecht

3
00:20.830 --> 00:28.560
zwischen vielen Individuen geteilt werden; Aggregierte Datenabfragen wirken auf Datengruppen, die ein gemeinsames Merkmal aufweisen

4
00:28.590 --> 00:33.830
Anzahl, Summe, Max, Min und Statistiken.

5
00:33.830 --> 00:38.820
Es gibt viele skalare Wertfunktionen, die auf eine Gruppe mit einem Rückgabewert 1 pro Gruppe reagieren.

6
00:39.050 --> 00:44.930
Dazu gehören: Zählen - gibt die Anzahl der Zeilen in einer Gruppe oder Tabelle zurück. Summe - Addieren aller Werte in einer Gruppe

7
00:44.930 --> 00:52.850
oder Tabelle; Max - Suchen Sie den maximalen Wert in einer Gruppe oder Tabelle; Min - Finden Sie einen Mindestwert in einer Gruppe oder Tabelle,

8
00:52.940 --> 00:55.840
AVG - Finden Sie den Durchschnittswert in einer Gruppe pro Tabelle.

9
00:55.980 --> 01:00.900
STDEV - Suchen Sie die Standardabweichung in einer Gruppe oder Tabelle; Video-Demonstration.

10
01:01.160 --> 01:05.320
Er wird eine Auswahl der statistischen Funktionen zeigen, die in der vorherigen Folie erwähnt wurden.

11
01:07.800 --> 01:13.090
Okay, hier werden wir einige der skalaren Wertfunktionen in SQL Server demonstrieren.

12
01:13.200 --> 01:15.180
Beginnen wir also mit der Zählung

13
01:15.370 --> 01:16.360
Schauen wir uns unsere Büchertabelle an

14
01:20.710 --> 01:29.450
und sehen Sie nur drei Bücher in dieser Tabelle, damit wir count(*) verwenden können, um die Anzahl der Zeilen in der Tabelle anzuzeigen.

15
01:29.500 --> 01:29.800
Drei

16
01:34.300 --> 01:43.390
wir finden; Verwenden Sie sum(), um die Gesamtzahl der Seiten in allen Büchern in unserer Bibliothek zu finden.

17
01:43.450 --> 01:44.410
summe(Seiten)

18
01:48.030 --> 01:50.140
1177

19
01:50.360 --> 01:56.230
Sie können die maximale Anzahl von Seiten in jedem Buch in unserer Bibliothek finden.

20
01:56.240 --> 02:01.100
438;  oder das kürzeste Buch in unserer Bibliothek - 

21
02:01.290 --> 02:14.110
durch Min;  326; die durchschnittliche Buchlänge in unserer Bibliothek 392; oder die Standardabweichung der

22
02:14.110 --> 02:15.440
Seiten in unserer Bibliothek.

23
02:15.440 --> 02:16.270
Wäre 58

24
02:19.960 --> 02:25.720
Group by ist eine Klausel, die eine Tabelle in Datengruppen unterteilt, sodass skalare

25
02:25.720 --> 02:27.910
für jede Datengruppe verwendet werden.

26
02:27.970 --> 02:34.630
Eine Bank könnte z. B. "group by" verwenden, um den durchschnittlichen Banksaldo per Postleitzahl / Postleitzahl zu bestimmen.

27
02:35.260 --> 02:42.160
Wählen Sie ZIPcode,avg(balance) aus BankAccounts Group per ZIPCode

28
02:42.160 --> 02:46.840
Video-Demonstration.

29
02:47.170 --> 02:53.520
Hier werden wir die Gruppe für Klausel demonstrieren; die Anzahl der Bücher, die von jedem Autor geschrieben wurden.

30
02:53.770 --> 03:01.080
Finden Sie die Anzahl der Seiten, die von jedem Autor geschrieben wurden, sortiert nach Seiten;  

31
03:01.080 --> 03:02.030
Hier werde ich die Gruppe nach Klausel demonstrieren.

32
03:02.130 --> 03:07.140
Erstens die Anzahl der von jedem Autor geschriebenen Bücher aufzulisten und zweitens die Anzahl der Seiten aufzulisten

33
03:07.140 --> 03:09.380
von jedem Autor nach Seiten geordnet.

34
03:10.170 --> 03:17.190
Also gruppieren wir nach dem Namen des Autors und verwenden dann in erster Linie die Anzahl, um die Zahl zu finden.

35
03:17.190 --> 03:23.220
von Büchern und Summe in der zweiten Instanz, um alle Seiten addieren.

36
03:23.340 --> 03:25.100
Lassen Sie uns also zuerst unsere grundlegende Abfrage schreiben

37
03:29.280 --> 03:31.760
* vom Autor auswählen ; um unsere Autoren zu bekommen.

38
03:31.840 --> 03:41.500
Wir müssen uns dem jetzt auf dem Buchautortisch anschließen;
BookAuthor ba auf ba.authorId = a.id beitreten

39
03:46.880 --> 03:49.420
und um dies auf den Namen des Autors zu gruppieren

40
03:53.310 --> 03:55.190
, bevor ich diese Abfrage ausführe.

41
03:55.190 --> 04:03.590
Es wird ein Fehler verursacht, es sei denn, Sie ändern den Stern in die eine Spaltengruppierung nach; , um den Fehler zu demonstrieren.

42
04:03.610 --> 04:14.190
Wenn ich versuche, dies auszuführen; sie besagt, dass sie in der Auswahlliste ungültig ist. also, wenn ich nur Autorname statt sagen

43
04:14.190 --> 04:18.130
von Star Bekomme ich den Autorennamen.

44
04:18.750 --> 04:22.350
Jetzt kann ich skalare Wertfunktionen wie Count hinzufügen

45
04:26.710 --> 04:29.660
es zeigt mir nun, dass J.K. Rowling zwei Bücher geschrieben hat.

46
04:30.140 --> 04:43.820
Dhonielle hat eine geschrieben; und Sona hat einen geschrieben; Wenn wir also unsere Seiten summieren wollen, können wir 

47
04:44.060 --> 04:46.160
Aber zuerst müssen wir uns auf den Büchertisch einlassen

48
04:51.600 --> 04:53.510
Buche b auf b.id = ba.bookid beitreten

49
04:53.920 --> 04:55.520
Buche b auf b.id = ba.bookid beitreten

50
04:55.770 --> 04:57.350
Buche b auf b.id = ba.bookid beitreten

51
05:00.900 --> 05:01.800
einen kurzen Blick darauf.

52
05:11.690 --> 05:15.280
Hier haben wir also alle Tabellenunfraktion

53
05:15.450 --> 05:17.110
Wir wollen uns darauf ein.

54
05:17.210 --> 05:20.890
Nun, um auf der Seitentabelle und Gruppe nach dem Namen des Autors zu summieren

55
05:24.090 --> 05:35.280
Gruppe nach authorName ... summe(Seiten)

56
05:35.520 --> 05:43.100
Und der letzte Teil davon ist, nach den Seiten zu bestellen, die Sie einfach eingeben können; Bestellung nach Sum(Seiten)

57
05:49.050 --> 05:52.900
und diese Liste ist nun nach Gesamtzahl der Seiten sortiert.

58
05:54.860 --> 05:57.650
Um dies prägnanter zu machen, können wir diesem einen Spalten-Alias geben

59
06:01.900 --> 06:12.870
und den Spaltenalias in die Reihenfolge nach einbeziehen; und wir haben jetzt einen Namen für diese Spalte. 

60
06:13.020 --> 06:15.630
Mit Klausel; Ähnlich ist die Where-Klausel für Gruppen.

61
06:16.470 --> 06:21.930
Wenn also eine Bank Postleitzahlen nur dort auflisten wollte, wo der durchschnittliche Bankkontosaldo über einer Million betrug

62
06:21.930 --> 06:28.200
Dollar, die sie dann verwenden könnten; Wählen Sie POSTleitzahl, avg(balance) von bankAccounts

63
06:28.860 --> 06:37.720
Gruppe nach Postleitzahl mit avg(balance)>1000000

64
06:37.910 --> 06:43.210
Hier ist eine Demonstration der Mitklausel; Wo werden Sie Listenautoren anzeigen, die mindestens

65
06:43.210 --> 06:45.630
zwei Bücher.

66
06:45.860 --> 06:52.290
Okay, hier gehen wir, um zu zeigen, dass mit Klausel; autoren auflisten, die mindestens zwei Bücher geschrieben haben.

67
06:52.400 --> 06:58.100
Also wählen wir noch einmal aus der Autorentabelle aus, die auf der Buchautorentabelle

68
06:58.100 --> 07:06.730
eine Zählung auf jeden Autor ausführen; Wählen * von Autoren

69
07:10.800 --> 07:12.160
Join auf der Bookauthor-Tabelle

70
07:22.330 --> 07:33.880
Wir möchten nun nur den Namen des Autors gruppieren und eine Anzahl

71
07:34.140 --> 07:40.320
Jetzt kann nichts in der Auswahlliste angezeigt werden, es sei denn, es ist in der Gruppe nach Klausel oder wenn es sich um eine Skalarfunktion handelt.

72
07:44.630 --> 07:53.210
Fügen Sie eine Anzahl ein.

73
07:53.320 --> 07:58.190
Jetzt haben wir alle Autoren und die Anzahl der Bücher, die ich geschrieben habe.

74
07:58.290 --> 08:02.220
Jetzt möchten Sie dies auf alle beschränken, die mindestens zwei Bücher geschrieben haben.

75
08:02.310 --> 08:04.620
So kann ich sagen, mit count(*)>=2

76
08:13.410 --> 08:14.870
und es gibt J.K. Rowling zurück

77
08:18.230 --> 08:23.870
systemglobale Variablen; Es gibt bestimmte Variablen, die auf SQL-Server systemweit verfügbar sind.

78
08:24.150 --> 08:26.230
und sind nicht vom Datenbankkontext abhängig.

79
08:26.270 --> 08:32.260
Dazu gehören @@connections anzahl der zum Start gestarteten Datenbankverbindungen. @@identity die letzte Identität

80
08:32.410 --> 08:40.070
Spalte eingefügt; @@CPU_Busy die Anzahl der Millisekunden, siehe SQL Server hat die CPU verwendet.

81
08:40.100 --> 08:45.400
@@Language - Die Sprache, die derzeit von SQL Server verwendet wird. @@RowCount die Anzahl der Zeilen, die von der letzten SQL-Anweisung bewirkt werden

82
08:46.070 --> 08:51.290
@@SERVERNAME Der Name des SQL-Servers;  @@VERSION die Version von SQL Server.

83
08:53.150 --> 08:58.960
Videodemonstration; Hier werden einige systemglobale Variablen demonstriert, um eine einfache Diagnose zu generieren

84
08:58.960 --> 09:01.410
Bericht für einen anderen Entwickler.

85
09:01.720 --> 09:08.500
Wir möchten die genaue SQL Server-Version an einen Entwickler melden, und Sie möchten überprüfen, ob übermäßige Verbindungen hergestellt werden.

86
09:08.620 --> 09:12.150
oder CPU-Auslastung.

87
09:12.320 --> 09:15.790
Okay, hier werden wir einige systemglobale Variablen demonstrieren.

88
09:16.420 --> 09:19.910
Daher möchten wir die genaue SQL-Server-Version an Entwickler melden.

89
09:19.930 --> 09:22.350
Also lassen Sie uns diese einfach die aktuelle Version auswählen

90
09:25.540 --> 09:27.740
jetzt wird dies abgeschnitten.

91
09:27.800 --> 09:32.850
Vielleicht möchten Sie dies also eher als Text denn als Raster sehen.

92
09:32.920 --> 09:36.590
In welchem Fall können wir Ergebnisse in Text gehen.

93
09:38.820 --> 09:43.510
Und das ist unsere komplette SQL-Server-Version

94
09:45.270 --> 09:52.560
Werfen wir einen Blick; zum Beispiel; unsere Anzahl der Verbindungen OK.

95
09:52.570 --> 09:54.680
Wir haben zweihundertneunzig.

96
09:54.700 --> 09:56.100
Das ist eine ganze Menge.

97
09:56.110 --> 10:03.070
Mal sehen, was passiert, wenn wir SQL Server zurücksetzen und diese Abfrage erneut ausführen, also klicken wir mit der rechten Maustaste

98
10:16.870 --> 10:24.330
und lassen Sie uns dies wiederholen; und wir sind wieder unten.

99
10:24.510 --> 10:25.320
Jetzt ist es an dir vorbei.

100
10:25.740 --> 10:27.380
Mal sehen, ob Sie das Gelernte anwenden können.

101
10:28.290 --> 10:33.690
Schreiben Sie eine Abfrage, die zeigt, wie viele Studenten wir in jedem Monat des Jahres geboren haben.

102
10:34.050 --> 10:40.590
Sie können dieses Video jetzt anhalten und diese Abfrage ausprobieren.

103
10:41.130 --> 10:41.580
Okay.

104
10:41.590 --> 10:46.540
Wir werden also eine Abfrage schreiben, die zeigt, wie viele Schüler in jedem Monat des Jahres geboren wurden.

105
10:46.540 --> 10:51.850
Ich hoffe, Sie haben dies einen Versuch zuerst gegeben haben, um nicht zu sein, können Sie dieses Video jetzt pausieren und es versuchen.

106
10:52.380 --> 10:54.160
OK, also hier ist die Lösung.

107
10:54.200 --> 11:03.250
Wir wollen unsere Studenten am Tisch sehen.

108
11:03.460 --> 11:12.190
Wir brauchen eine Funktion, um den Monat des Geburtsdatums zu bestimmen, den ich month(dateOfBirth) verwenden werde

109
11:17.250 --> 11:19.650
3 für den 1. März für Januar.

110
11:20.990 --> 11:22.130
Geben wir ihm einen Namen.

111
11:22.290 --> 11:25.670
MonthOfBirth mit einem Spalten-Alias

112
11:31.290 --> 11:41.190
Wir können keine * verwenden, da wir jetzt eine Group-by-Klausel verwenden möchten. Gruppe nach MonatVon der Geburt; so wird dies zurückkehren

113
11:42.170 --> 11:51.950
zwei Reihen eins für März eins für Januar Januar März und jetzt wollen wir wissen, wie viele Studenten in jedem

114
11:51.950 --> 11:54.060
Gruppe, die wir gerade benutzt haben.

115
11:54.230 --> 11:54.560
Count

116
12:02.100 --> 12:06.010
für Januar bis März.

117
12:06.080 --> 12:06.710
Geben Sie uns einen Namen.

118
12:14.100 